{% extends "base.html" %}

{% block title %}Algorithms - Data Structure Visualizer{% endblock %}

{% block content %}
<div class="algorithms-page">
    <div class="container">
        <div class="page-header">
            <h1>Sorting Algorithms Explained</h1>
            <p class="page-subtitle">Learn about different sorting algorithms, their complexities, and how they work</p>
        </div>

        <!-- Algorithm Navigation -->
        <div class="algorithm-nav">
            <div class="nav-tabs">
                <button class="nav-tab active" data-target="bubble">Bubble Sort</button>
                <button class="nav-tab" data-target="insertion">Insertion Sort</button>
                <button class="nav-tab" data-target="selection">Selection Sort</button>
                <button class="nav-tab" data-target="quick">Quick Sort</button>
                <button class="nav-tab" data-target="merge">Merge Sort</button>
                <button class="nav-tab" data-target="heap">Heap Sort</button>
            </div>
        </div>

        <!-- Bubble Sort Section -->
        <div class="algorithm-section active" id="bubble">
            <div class="algorithm-header">
                <h2>Bubble Sort</h2>
                <div class="complexity-badge">O(nÂ²)</div>
            </div>
            
            <div class="algorithm-content">
                <div class="what-is-it">
                    <h3>What is Bubble Sort?</h3>
                    <p>Bubble Sort is a simple comparison-based sorting algorithm. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The algorithm gets its name because smaller elements "bubble" to the top of the list with each pass.</p>
                </div>

                <div class="how-it-works">
                    <h3>How it Works</h3>
                    <ol>
                        <li>Start from the first element and compare it with the next element</li>
                        <li>If the first element is greater than the second, swap them</li>
                        <li>Move to the next pair and repeat the comparison</li>
                        <li>Continue until the end of the list</li>
                        <li>Repeat the entire process for the remaining unsorted portion</li>
                        <li>Stop when no more swaps are needed</li>
                    </ol>
                </div>

                <div class="complexity-table">
                    <h3>Time & Space Complexity</h3>
                    <table>
                        <tr>
                            <th>Case</th>
                            <th>Time Complexity</th>
                            <th>Space Complexity</th>
                        </tr>
                        <tr>
                            <td>Best</td>
                            <td>O(n)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Average</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Worst</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                        </tr>
                    </table>
                </div>

                <div class="chart-container">
                    <h3>Performance Comparison</h3>
                    <div class="chart-placeholder">
                        <p>ðŸ“Š Interactive performance charts will be added soon!</p>
                    </div>
                </div>

                <div class="learn-more">
                    <button class="accordion-btn">Learn More</button>
                    <div class="accordion-content">
                        <h4>Characteristics</h4>
                        <ul>
                            <li><strong>Stable:</strong> Maintains relative order of equal elements</li>
                            <li><strong>In-place:</strong> Requires only O(1) extra space</li>
                            <li><strong>Adaptive:</strong> Can detect if the list is already sorted</li>
                        </ul>
                        <h4>When to Use</h4>
                        <p>Bubble Sort is mainly used for educational purposes due to its simplicity. It's not practical for large datasets but can be useful for small lists or when simplicity is more important than efficiency.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Insertion Sort Section -->
        <div class="algorithm-section" id="insertion">
            <div class="algorithm-header">
                <h2>Insertion Sort</h2>
                <div class="complexity-badge">O(nÂ²)</div>
            </div>
            
            <div class="algorithm-content">
                <div class="what-is-it">
                    <h3>What is Insertion Sort?</h3>
                    <p>Insertion Sort builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms, but it has several advantages: it is simple to implement, efficient for small datasets, and stable.</p>
                </div>

                <div class="how-it-works">
                    <h3>How it Works</h3>
                    <ol>
                        <li>Start with the second element (index 1)</li>
                        <li>Compare it with all elements to its left</li>
                        <li>Insert the element in the correct position</li>
                        <li>Move to the next element and repeat</li>
                        <li>Continue until all elements are in their correct positions</li>
                    </ol>
                </div>

                <div class="complexity-table">
                    <h3>Time & Space Complexity</h3>
                    <table>
                        <tr>
                            <th>Case</th>
                            <th>Time Complexity</th>
                            <th>Space Complexity</th>
                        </tr>
                        <tr>
                            <td>Best</td>
                            <td>O(n)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Average</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Worst</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                        </tr>
                    </table>
                </div>

                <div class="chart-container">
                    <h3>Performance Comparison</h3>
                    <div class="chart-placeholder">
                        <p>ðŸ“Š Interactive performance charts will be added soon!</p>
                    </div>
                </div>

                <div class="learn-more">
                    <button class="accordion-btn">Learn More</button>
                    <div class="accordion-content">
                        <h4>Characteristics</h4>
                        <ul>
                            <li><strong>Stable:</strong> Maintains relative order of equal elements</li>
                            <li><strong>In-place:</strong> Requires only O(1) extra space</li>
                            <li><strong>Online:</strong> Can sort a list as it receives it</li>
                        </ul>
                        <h4>When to Use</h4>
                        <p>Insertion Sort is efficient for small datasets and is often used as a building block for more complex algorithms like Timsort. It's also good for nearly sorted data.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Selection Sort Section -->
        <div class="algorithm-section" id="selection">
            <div class="algorithm-header">
                <h2>Selection Sort</h2>
                <div class="complexity-badge">O(nÂ²)</div>
            </div>
            
            <div class="algorithm-content">
                <div class="what-is-it">
                    <h3>What is Selection Sort?</h3>
                    <p>Selection Sort is an in-place comparison sorting algorithm. It has O(nÂ²) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort.</p>
                </div>

                <div class="how-it-works">
                    <h3>How it Works</h3>
                    <ol>
                        <li>Find the minimum element in the unsorted portion</li>
                        <li>Swap it with the first element of the unsorted portion</li>
                        <li>Move the boundary of the sorted portion one position to the right</li>
                        <li>Repeat until the entire list is sorted</li>
                    </ol>
                </div>

                <div class="complexity-table">
                    <h3>Time & Space Complexity</h3>
                    <table>
                        <tr>
                            <th>Case</th>
                            <th>Time Complexity</th>
                            <th>Space Complexity</th>
                        </tr>
                        <tr>
                            <td>Best</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Average</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Worst</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                        </tr>
                    </table>
                </div>

                <div class="chart-container">
                    <h3>Performance Comparison</h3>
                    <div class="chart-placeholder">
                        <p>ðŸ“Š Interactive performance charts will be added soon!</p>
                    </div>
                </div>

                <div class="learn-more">
                    <button class="accordion-btn">Learn More</button>
                    <div class="accordion-content">
                        <h4>Characteristics</h4>
                        <ul>
                            <li><strong>Not Stable:</strong> May change relative order of equal elements</li>
                            <li><strong>In-place:</strong> Requires only O(1) extra space</li>
                            <li><strong>Simple:</strong> Easy to understand and implement</li>
                        </ul>
                        <h4>When to Use</h4>
                        <p>Selection Sort is mainly used for educational purposes. It's not recommended for large datasets due to its O(nÂ²) time complexity.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Sort Section -->
        <div class="algorithm-section" id="quick">
            <div class="algorithm-header">
                <h2>Quick Sort</h2>
                <div class="complexity-badge">O(n log n)</div>
            </div>
            
            <div class="algorithm-content">
                <div class="what-is-it">
                    <h3>What is Quick Sort?</h3>
                    <p>Quick Sort is a divide-and-conquer algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot.</p>
                </div>

                <div class="how-it-works">
                    <h3>How it Works</h3>
                    <ol>
                        <li>Choose a pivot element from the array</li>
                        <li>Partition the array so that elements smaller than pivot are on the left</li>
                        <li>Elements greater than pivot are on the right</li>
                        <li>Recursively apply the same process to the left and right sub-arrays</li>
                        <li>Combine the results</li>
                    </ol>
                </div>

                <div class="complexity-table">
                    <h3>Time & Space Complexity</h3>
                    <table>
                        <tr>
                            <th>Case</th>
                            <th>Time Complexity</th>
                            <th>Space Complexity</th>
                        </tr>
                        <tr>
                            <td>Best</td>
                            <td>O(n log n)</td>
                            <td>O(log n)</td>
                        </tr>
                        <tr>
                            <td>Average</td>
                            <td>O(n log n)</td>
                            <td>O(log n)</td>
                        </tr>
                        <tr>
                            <td>Worst</td>
                            <td>O(nÂ²)</td>
                            <td>O(n)</td>
                        </tr>
                    </table>
                </div>

                <div class="chart-container">
                    <h3>Performance Comparison</h3>
                    <div class="chart-placeholder">
                        <p>ðŸ“Š Interactive performance charts will be added soon!</p>
                    </div>
                </div>

                <div class="learn-more">
                    <button class="accordion-btn">Learn More</button>
                    <div class="accordion-content">
                        <h4>Characteristics</h4>
                        <ul>
                            <li><strong>Not Stable:</strong> May change relative order of equal elements</li>
                            <li><strong>In-place:</strong> Can be implemented with O(log n) space</li>
                            <li><strong>Cache-friendly:</strong> Good locality of reference</li>
                        </ul>
                        <h4>When to Use</h4>
                        <p>Quick Sort is one of the most efficient sorting algorithms and is widely used in practice. It's the default sorting algorithm in many programming languages.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Merge Sort Section -->
        <div class="algorithm-section" id="merge">
            <div class="algorithm-header">
                <h2>Merge Sort</h2>
                <div class="complexity-badge">O(n log n)</div>
            </div>
            
            <div class="algorithm-content">
                <div class="what-is-it">
                    <h3>What is Merge Sort?</h3>
                    <p>Merge Sort is a divide-and-conquer algorithm that divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.</p>
                </div>

                <div class="how-it-works">
                    <h3>How it Works</h3>
                    <ol>
                        <li>Divide the array into two halves</li>
                        <li>Recursively sort the left half</li>
                        <li>Recursively sort the right half</li>
                        <li>Merge the two sorted halves</li>
                        <li>Continue until the entire array is sorted</li>
                    </ol>
                </div>

                <div class="complexity-table">
                    <h3>Time & Space Complexity</h3>
                    <table>
                        <tr>
                            <th>Case</th>
                            <th>Time Complexity</th>
                            <th>Space Complexity</th>
                        </tr>
                        <tr>
                            <td>Best</td>
                            <td>O(n log n)</td>
                            <td>O(n)</td>
                        </tr>
                        <tr>
                            <td>Average</td>
                            <td>O(n log n)</td>
                            <td>O(n)</td>
                        </tr>
                        <tr>
                            <td>Worst</td>
                            <td>O(n log n)</td>
                            <td>O(n)</td>
                        </tr>
                    </table>
                </div>

                <div class="chart-container">
                    <h3>Performance Comparison</h3>
                    <div class="chart-placeholder">
                        <p>ðŸ“Š Interactive performance charts will be added soon!</p>
                    </div>
                </div>

                <div class="learn-more">
                    <button class="accordion-btn">Learn More</button>
                    <div class="accordion-content">
                        <h4>Characteristics</h4>
                        <ul>
                            <li><strong>Stable:</strong> Maintains relative order of equal elements</li>
                            <li><strong>Predictable:</strong> Always O(n log n) time complexity</li>
                            <li><strong>External:</strong> Can sort data that doesn't fit in memory</li>
                        </ul>
                        <h4>When to Use</h4>
                        <p>Merge Sort is excellent when you need a stable, predictable O(n log n) sorting algorithm. It's often used for sorting linked lists and external sorting.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Heap Sort Section -->
        <div class="algorithm-section" id="heap">
            <div class="algorithm-header">
                <h2>Heap Sort</h2>
                <div class="complexity-badge">O(n log n)</div>
            </div>
            
            <div class="algorithm-content">
                <div class="what-is-it">
                    <h3>What is Heap Sort?</h3>
                    <p>Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It's similar to selection sort but uses a heap to find the maximum element more efficiently.</p>
                </div>

                <div class="how-it-works">
                    <h3>How it Works</h3>
                    <ol>
                        <li>Build a max heap from the input data</li>
                        <li>At this point, the largest item is at the root of the heap</li>
                        <li>Replace it with the last item of the heap</li>
                        <li>Reduce the heap size by one</li>
                        <li>Heapify the root of the tree</li>
                        <li>Repeat until the heap size is 1</li>
                    </ol>
                </div>

                <div class="complexity-table">
                    <h3>Time & Space Complexity</h3>
                    <table>
                        <tr>
                            <th>Case</th>
                            <th>Time Complexity</th>
                            <th>Space Complexity</th>
                        </tr>
                        <tr>
                            <td>Best</td>
                            <td>O(n log n)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Average</td>
                            <td>O(n log n)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Worst</td>
                            <td>O(n log n)</td>
                            <td>O(1)</td>
                        </tr>
                    </table>
                </div>

                <div class="chart-container">
                    <h3>Performance Comparison</h3>
                    <div class="chart-placeholder">
                        <p>ðŸ“Š Interactive performance charts will be added soon!</p>
                    </div>
                </div>

                <div class="learn-more">
                    <button class="accordion-btn">Learn More</button>
                    <div class="accordion-content">
                        <h4>Characteristics</h4>
                        <ul>
                            <li><strong>Not Stable:</strong> May change relative order of equal elements</li>
                            <li><strong>In-place:</strong> Requires only O(1) extra space</li>
                            <li><strong>Predictable:</strong> Always O(n log n) time complexity</li>
                        </ul>
                        <h4>When to Use</h4>
                        <p>Heap Sort is useful when you need an in-place sorting algorithm with guaranteed O(n log n) performance. It's also the basis for priority queues.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Comparison Chart -->
        <div class="comparison-section">
            <h2>Algorithm Comparison</h2>
            <div class="chart-container">
                <div class="chart-placeholder">
                    <p>ðŸ“Š Interactive comparison charts will be added soon!</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Tab navigation
    const tabs = document.querySelectorAll('.nav-tab');
    const sections = document.querySelectorAll('.algorithm-section');

    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const target = this.getAttribute('data-target');
            
            // Remove active class from all tabs and sections
            tabs.forEach(t => t.classList.remove('active'));
            sections.forEach(s => s.classList.remove('active'));
            
            // Add active class to clicked tab and corresponding section
            this.classList.add('active');
            document.getElementById(target).classList.add('active');
        });
    });

    // Accordion functionality
    const accordionBtns = document.querySelectorAll('.accordion-btn');
    accordionBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const content = this.nextElementSibling;
            const isActive = this.classList.contains('active');
            
            // Close all accordions
            accordionBtns.forEach(b => {
                b.classList.remove('active');
                b.nextElementSibling.style.maxHeight = null;
            });
            
            // Open clicked accordion if it wasn't active
            if (!isActive) {
                this.classList.add('active');
                content.style.maxHeight = content.scrollHeight + 'px';
            }
        });
    });
});
</script>
{% endblock %}
